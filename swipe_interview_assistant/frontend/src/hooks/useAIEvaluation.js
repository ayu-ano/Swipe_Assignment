import { useState, useCallback } from 'react';
import { evaluateAnswer, generateQuestion, generateSummary } from '../services/aiService';

const useAIEvaluation = () => {
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState(null);

  // Evaluate candidate's answer
  const evaluateCandidateAnswer = useCallback(async (question, answer, difficulty) => {
    if (!question || !answer) {
      throw new Error('Question and answer are required for evaluation');
    }

    setIsLoading(true);
    setError(null);

    try {
      const evaluation = await evaluateAnswer(question, answer, difficulty);
      
      // Validate evaluation response
      if (!evaluation || typeof evaluation.score !== 'number') {
        throw new Error('Invalid evaluation response from AI service');
      }

      // Ensure score is within bounds
      const normalizedScore = Math.max(0, Math.min(100, evaluation.score));
      
      return {
        score: normalizedScore,
        feedback: evaluation.feedback || generateDefaultFeedback(normalizedScore, difficulty),
        strengths: evaluation.strengths || [],
        improvements: evaluation.improvements || []
      };

    } catch (err) {
      const errorMessage = err.message || 'Failed to evaluate answer. Please try again.';
      setError(errorMessage);
      console.error('AI Evaluation error:', err);
      
      // Return fallback evaluation
      return getFallbackEvaluation(difficulty);
    } finally {
      setIsLoading(false);
    }
  }, []);

  // Generate interview question
  const generateInterviewQuestion = useCallback(async (index, difficulty) => {
    setIsLoading(true);
    setError(null);

    try {
      const question = await generateQuestion(index, difficulty);
      
      if (!question || !question.text) {
        throw new Error('Invalid question generated by AI service');
      }

      return {
        id: `question_${index}_${Date.now()}`,
        text: question.text,
        difficulty: difficulty,
        index: index,
        category: question.category || getCategoryForDifficulty(difficulty),
        type: question.type || 'technical'
      };

    } catch (err) {
      const errorMessage = err.message || 'Failed to generate question. Please try again.';
      setError(errorMessage);
      console.error('AI Question generation error:', err);
      
      // Return fallback question
      return getFallbackQuestion(index, difficulty);
    } finally {
      setIsLoading(false);
    }
  }, []);

  // Generate candidate summary
  const generateCandidateSummary = useCallback(async (answers, finalScore) => {
    if (!answers || answers.length === 0) {
      return generateDefaultSummary(finalScore);
    }

    setIsLoading(true);
    setError(null);

    try {
      const summary = await generateSummary(answers, finalScore);
      
      if (!summary) {
        throw new Error('Failed to generate summary');
      }

      return summary.trim();

    } catch (err) {
      console.error('AI Summary generation error:', err);
      
      // Return fallback summary
      return generateDefaultSummary(finalScore, answers);
    } finally {
      setIsLoading(false);
    }
  }, []);

  // Analyze interview performance
  const analyzePerformance = useCallback((answers) => {
    if (!answers || answers.length === 0) {
      return getEmptyPerformanceAnalysis();
    }

    const totalScore = answers.reduce((sum, answer) => sum + answer.score, 0);
    const averageScore = Math.round(totalScore / answers.length);
    
    const performanceByDifficulty = {
      easy: answers.filter(a => a.difficulty === 'easy'),
      medium: answers.filter(a => a.difficulty === 'medium'),
      hard: answers.filter(a => a.difficulty === 'hard')
    };

    const strengths = answers
      .filter(a => a.score >= 80)
      .map(a => a.difficulty);

    const improvements = answers
      .filter(a => a.score < 60)
      .map(a => a.difficulty);

    return {
      averageScore,
      totalQuestions: answers.length,
      performanceByDifficulty: {
        easy: performanceByDifficulty.easy.length > 0 
          ? Math.round(performanceByDifficulty.easy.reduce((sum, a) => sum + a.score, 0) / performanceByDifficulty.easy.length)
          : 0,
        medium: performanceByDifficulty.medium.length > 0
          ? Math.round(performanceByDifficulty.medium.reduce((sum, a) => sum + a.score, 0) / performanceByDifficulty.medium.length)
          : 0,
        hard: performanceByDifficulty.hard.length > 0
          ? Math.round(performanceByDifficulty.hard.reduce((sum, a) => sum + a.score, 0) / performanceByDifficulty.hard.length)
          : 0
      },
      strengths: [...new Set(strengths)],
      improvements: [...new Set(improvements)],
      completionRate: Math.round((answers.filter(a => !a.autoSubmitted).length / answers.length) * 100)
    };
  }, []);

  // Get confidence level for AI evaluation
  const getConfidenceLevel = useCallback((score, difficulty) => {
    const baseConfidence = 0.8; // 80% base confidence
    
    // Adjust confidence based on answer quality and question difficulty
    let adjustment = 0;
    
    if (score >= 80) adjustment += 0.15;
    else if (score >= 60) adjustment += 0.05;
    else adjustment -= 0.1;
    
    if (difficulty === 'hard') adjustment -= 0.05;
    else if (difficulty === 'easy') adjustment += 0.05;
    
    const finalConfidence = Math.max(0.5, Math.min(0.95, baseConfidence + adjustment));
    
    return {
      level: finalConfidence,
      label: finalConfidence >= 0.8 ? 'High' : finalConfidence >= 0.6 ? 'Medium' : 'Low'
    };
  }, []);

  // Clear error
  const clearError = useCallback(() => {
    setError(null);
  }, []);

  return {
    // State
    isLoading,
    error,
    
    // Actions
    evaluateAnswer: evaluateCandidateAnswer,
    generateQuestion: generateInterviewQuestion,
    generateSummary: generateCandidateSummary,
    analyzePerformance,
    getConfidenceLevel,
    
    // Utilities
    clearError
  };
};

// Helper functions
const generateDefaultFeedback = (score, difficulty) => {
  if (score >= 80) {
    return `Excellent answer! You demonstrated strong understanding of this ${difficulty} level concept.`;
  } else if (score >= 60) {
    return `Good answer. You showed understanding but could provide more depth or examples for this ${difficulty} question.`;
  } else {
    return `This area needs improvement. Consider reviewing ${difficulty} level concepts and practicing more.`;
  }
};

const getFallbackEvaluation = (difficulty) => {
  const baseScore = difficulty === 'easy' ? 70 : difficulty === 'medium' ? 50 : 30;
  return {
    score: baseScore,
    feedback: `AI evaluation temporarily unavailable. This is a fallback assessment for ${difficulty} difficulty.`,
    strengths: ['Technical understanding'],
    improvements: ['Could use more specific examples']
  };
};

const getFallbackQuestion = (index, difficulty) => {
  const questions = {
    easy: [
      "Explain the concept of React components and how they help in building user interfaces.",
      "What is the virtual DOM in React and how does it improve performance?"
    ],
    medium: [
      "How would you handle state management in a large React application? Discuss different approaches.",
      "Explain the difference between client-side rendering and server-side rendering in web applications."
    ],
    hard: [
      "Describe how you would optimize a React application for performance. Include specific techniques and tools.",
      "Explain microservices architecture and discuss when it's appropriate to use it over a monolith."
    ]
  };

  const questionPool = questions[difficulty] || questions.easy;
  const questionIndex = index % questionPool.length;
  
  return {
    id: `fallback_question_${index}`,
    text: questionPool[questionIndex],
    difficulty: difficulty,
    index: index,
    category: getCategoryForDifficulty(difficulty),
    type: 'technical'
  };
};

const getCategoryForDifficulty = (difficulty) => {
  const categories = {
    easy: 'react-basics',
    medium: 'architecture',
    hard: 'advanced-concepts'
  };
  return categories[difficulty] || 'general';
};

const generateDefaultSummary = (finalScore, answers = []) => {
  const strengths = answers.filter(a => a.score >= 70).length;
  
  if (finalScore >= 80) {
    return `Candidate demonstrated excellent technical skills with strong performance across ${strengths} out of ${answers.length} questions. Shows deep understanding of full-stack concepts and would be a valuable addition to any development team.`;
  } else if (finalScore >= 60) {
    return `Candidate showed good technical competency with solid understanding of core concepts. Performed well in ${strengths} areas and has a good foundation for further development.`;
  } else {
    return `Candidate displayed basic understanding of technical concepts but requires further development and practice. Recommended to focus on fundamental concepts and gain more hands-on experience.`;
  }
};

const getEmptyPerformanceAnalysis = () => ({
  averageScore: 0,
  totalQuestions: 0,
  performanceByDifficulty: { easy: 0, medium: 0, hard: 0 },
  strengths: [],
  improvements: [],
  completionRate: 0
});

export default useAIEvaluation;